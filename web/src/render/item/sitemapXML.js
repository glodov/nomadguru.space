const fs = require('node:fs');
const path = require('node:path');
const { runtime } = require('../../runtime');
const { detectLang, getDataFile } = require('../../data');
const { ensureDirectory } = require('../../fs');
const { escapeHtml } = require('../../ejs/functions');

/*
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
	<sitemap>
		<loc>https://yaro.page/sitemap/posts.xml</loc>
		<lastmod>2024-02-27T16:42:23+00:00</lastmod>
	</sitemap>
	<sitemap>
		<loc>https://yaro.page/sitemap/author.xml</loc>
		<lastmod>2023-05-05T05:46:53+00:00</lastmod>
	</sitemap>
</sitemapindex>
*/
/*
<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="//eaukraine.eu/wp-content/plugins/wordpress-seo/css/main-sitemap.xsl"?>
<urlset xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:image="http://www.google.com/schemas/sitemap-image/1.1" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd http://www.google.com/schemas/sitemap-image/1.1 http://www.google.com/schemas/sitemap-image/1.1/sitemap-image.xsd" xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
	<url>
		<loc>https://yaro.page/page1.html</loc>
		<lastmod>2024-02-10T10:52:33+00:00</lastmod>
		<image:image>
			<image:loc>https://yaro.page/uploads/2024/02/thumbs_b_c_dab752dc1c0a7fb73468d7f3f363230c.jpg</image:loc>
		</image:image>
	</url>
	<url>
		<loc>https://yaro.page/page2.html</loc>
		<lastmod>2024-02-12T10:00:56+00:00</lastmod>
		<image:image>
			<image:loc>https://yaro.page/uploads/2024/02/RSK.jpg</image:loc>
		</image:image>
	</url>
</urlset>
<!-- XML Sitemap generated by nanâˆ™web --> 
*/

const blockRowsLimit = runtime['SITEMAP_BLOCK_ROWS'] || 999;
const blockSizeLimit = runtime['SITEMAP_BLOCK_SIZE'] || 0;
const SITEMAPS_DIR = path.join(runtime['STATIC_DIR'], 'sitemaps');
/**
 * @schema { file: { fp, rows: [int], size: [int], block: int } }
 */
const fps = {};

function closeAll() {
    Object.keys(fps).forEach(file => {
        if (fps[file].fp) {
            closeXML(fps[file]);
            fps[file].fp = null;
        }
    });
}

function blockFile(file, block = 0) {
    return file.replace(/\.xml$/, `-${parseInt(block) + 1}.xml`);
}

function saveSitemapIndex() {
    // write meta data about all sitemaps /public/sitemap.xml
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n'
    const meta = [];
    for (const file in fps) {
        const rows = fps[file].rows;
        const size = fps[file].size;
        const imgs = fps[file].imgs;
        // const fileUri = path.relative(runtime['STATIC_DIR'], file);
        // meta[fileUri] = [];
        for (const i in rows) {
            const sitemapFile = blockFile(file, i);
            const stat = fs.statSync(sitemapFile);
            const element = {
                loc: runtime['HOST'] + '/' + path.relative(runtime['STATIC_DIR'], sitemapFile),
                lastmod: stat.mtime.toISOString().slice(0, 19) + 'Z',
                rows: rows[i],
                images: imgs[i],
                size: size[i],
            };
            xml += '<sitemap>' + convertToXML(element) + '</sitemap>\n';
        }
    }
    const file = path.join(runtime['STATIC_DIR'], 'sitemap.xml');
    xml += '</sitemapindex>\n';
    fs.writeFileSync(file, xml);
}

function openFileIfNeeded(file) {
    ensureDirectory(path.dirname(file));
    if (typeof fps[file] === 'undefined') {
        fps[file] = { fp: null, rows: [0], imgs: [0], size: [0], block: 0 };
        fps[file].fp = openXML(file, fps[file]);
    }
    return fps[file];
}

function convertToXML(element) {
    let xml = '';
    for (const [key, value] of Object.entries(element)) {
        if (typeof value === 'object') {
            xml += `<${key}>`;
            xml += convertToXML(value);
            xml += `</${key}>`;
        } else {
            xml += `<${key}>${escapeHtml(value)}</${key}>`;
        }
    }
    return xml;
}

function openXML(file, info) {
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<urlset xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:image="http://www.google.com/schemas/sitemap-image/1.1" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd http://www.google.com/schemas/sitemap-image/1.1 http://www.google.com/schemas/sitemap-image/1.1/sitemap-image.xsd" xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
    const fp = fs.openSync(blockFile(file, info.block), 'w');
    fs.writeSync(fp, xml);
    return fp;
}

function closeXML(info) {
    fs.writeSync(info.fp, '</urlset>');
    fs.closeSync(info.fp);
    delete info['fp'];
}

function extractIntoFile(element, info, file) {
    const index = convertToXML(element);
    const size = Buffer.byteLength(index, 'utf8');
    const overLong = blockRowsLimit > 0 && info.rows[info.block] === blockRowsLimit;
    const overSize = blockSizeLimit > 0 && size + info.size[info.block] > blockSizeLimit;
    if (overLong || overSize) {
        closeXML(info);
        info.block++;
        info.fp = openXML(file, info);
        info.rows[info.block] = 0;
        info.imgs[info.block] = 0;
        info.size[info.block] = 0;
    }
    fs.writeSync(info.fp, index + '\n'); // Append newline for each entry
    info.rows[info.block]++;
    info.size[info.block] += size;
    if (index.includes('<image:image>')) info.imgs[info.block]++;
}

function decodeFilesInfo() {
    const files = {};
    for (const f in fps) {
        files[f] = Object.assign({}, fps[f]);
        delete files[f].fp;
    }
    return files;
}

function extract(item) {
    if (item['$redirect']) return null;
    if (item['$hidden']) return null;
    const file = getDataFile(item['$uri'], runtime['DATA_DIR']);
    const stat = fs.statSync(file);
    const res = {
        url: {
            loc: runtime['HOST'] + item['$uri'] + '.html',
            lastmod: stat.mtime.toISOString().slice(0, 19) + 'Z',
        },
    };
    if (item['ogImage']) {
        res.url['image:image'] = {
            'image:loc': '/' === item['ogImage'].slice(0, 1) ? runtime['HOST'] + item['ogImage'] : item['ogImage']
        };
    }
    return res;
}

function extractEvery(data, file) {
    const index = extract(data);
    if (!index) return { index: null, info: null };
    const info = openFileIfNeeded(file);
    extractIntoFile(index, info, file);
    return { index, info };
}

function sitemapXML(args) {
    const { data, filesIndex, filesLen } = args;
    if (false === data['$sitemap'] || !filesLen) {
        return { key: 'sitemapXML', out: { index: null, files: [], skip: true } };
    }
    const lang = data['$lang'] || detectLang(data['$uri'], data['global']?.['langs']);
    const file = path.join(SITEMAPS_DIR, `${lang}.xml`);
    // write index in /public/sitemaps/{lang}-{part}.xml
    const { index, info } = extractEvery(data, file);

    if (filesLen - 1 === filesIndex) {
        // if (info) closeXML(info);
        closeAll(); // Close all file descriptors
        saveSitemapIndex();
    }
    const files = decodeFilesInfo();
    return { key: 'sitemapXML', out: { index, files } };
}

module.exports = sitemapXML;